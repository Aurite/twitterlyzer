class FeedEntry < ActiveRecord::Base
  require 'open-uri'
  require 'simple-rss'
  require 'json'
  #require 'typhoeus'
  #include Typhoeus

  #Constants
  ENTRIES_PER_PAGE = 200
  TWITTER_USERNAME = "plotti"
  TWITTER_PASSWORD = "wrzesz"
  
  
  #define_remote_method :user_timeline, :path => '/statuses/user_timeline.rss',
  #                     :base_uri => "http://twitter.com",
  #                     :on_success => lambda {|response| SimpleRSS.parse(response.body)},
  #                     :on_failure => lambda {|response| puts "error code: #{response.code}"},
  #                     :headers => {"Authorization" => "Basic #{Base64.b64encode(TWITTER_USERNAME + ":" + TWITTER_PASSWORD)}"}


  #Associations
  belongs_to :person
  
  #Sphinx
  is_indexed :fields => ['text', 'author', 'url']
    
  #Determines number of feeds that have to be downloaded for a person
  #It can either be 0, all, or a number less than 200.
  def self.downloadable_feeds(person)
    db_feeds = person.feed_entries.all(:order => "published_at DESC")  
    i = 0
    
    if db_feeds.count > person.statuses_count
      person.update_attributes :statuses_count => db_feeds.count
      feeds_to_download = 0
    elsif db_feeds.count == person.statuses_count
      feeds_to_download = 0
    elsif db_feeds.count == 0
      feeds_to_download = person.statuses_count
    else      
      begin
        feeds = FeedEntry.user_timeline(:params => {:screen_name => person.username, :page => 1, :count => ENTRIES_PER_PAGE})
        feeds.entries.each do |entry|        
          #if entry.id == db_feeds.first.guid #Feedzirra
          if entry.guid == db_feeds.first.guid          
            feeds_to_download = i
            break
          end        
          i = i + 1
        end
      rescue
        SystemMessage.add_message("error", "Downloadable Feeds", "User " + person.username + " not found.")
      end
    end
        
    return feeds_to_download
  end

  #Collects all possible rss entries from one person on twitter 
  def self.collect_all_entries(person)
    
    #init
    feeds_to_download = FeedEntry.downloadable_feeds(person)          
    pages = feeds_to_download.to_f / ENTRIES_PER_PAGE.to_f
    pages = pages.ceil
    url_strings = []
    feeds = {}
    
    for page in 1..pages
      begin
        feeds[page] = FeedEntry.user_timeline(:params => {:screen_name => person.username, :page => page, :count => ENTRIES_PER_PAGE})
      rescue
        SystemMessage.add_message("error", "Collect all entries", "User " + person.username + " not found.")
      end      
    end
    
    feeds.each do |key, value|      
      FeedEntry.add_entries(value.entries, person)        
    end
    
    #update statuses count    
    person.update_attributes :statuses_count => person.feed_entries.count
    logger.info "Collect_all_entries -- Collected " + feeds_to_download.to_s + " feeds of of: " + person.username
    
    return feeds
  end
  
  def self.update_person_entries(person)
    page = 1  
    newer_entries_exist = true
    entries_to_add = []
    entries_pp = 50
    switch = true          
    latest_published_db_entry = person.feed_entries.maximum("published_at")
    if latest_published_db_entry == nil
      latest_published_db_entry = Time.at(0)
    end          
    while newer_entries_exist
      begin
        entries = FeedEntry.user_timeline(:params => {:id => person.twitter_id, :page => page, :count => entries_pp}).entries
      rescue
        puts "User not found: " + person.username
        entries = []
      end            
      if entries.count == 0
        newer_entries_exist = false
      end
      entries.each do |entry|
        if entry.pubDate > latest_published_db_entry
          entries_to_add << entry
        else
          newer_entries_exist = false
        end
      end
      # 50,50,50,50,200,200,....
      if page == 4 && switch
        entries_pp = 200
        page = 1
        switch = false
      end
      page = page + 1
    end    
    FeedEntry.add_entries(entries_to_add, person)
    person.update_attributes(:statuses_count => person.statuses_count + entries_to_add.count)
    logger.info(entries_to_add.count.to_s + " Entries updated for user: " + person.username)    
  end
  
  #Update persons
  def self.update_rss    
    Project.all.each do |project|      
      if project.monitor_feeds == true
        project.persons.each do |person|          
          Delayed::Job.enqueue(UpdateFeedEntriesJob.new(person.id))
        end
        SystemMessage.add_message("info", "Update RSS ",  "Scheduled tweets update for Project " + project.name + ".")
      end      
    end
  end
  
  #Returns number of remaining Twitter API Hits
  def self.get_remaining_api_hits()
    result = {}
    begin
      Timeout::timeout(5){
        buffer = open("http://twitter.com/account/rate_limit_status.json", :http_basic_authentication=>[TWITTER_USERNAME, TWITTER_PASSWORD]).read
        result = JSON.parse(buffer)
      }
    rescue Timeout::Error
      result['remaining_hits'] = "Twitter Timeout"
    end
    
    return result['remaining_hits']
  end
   
  private

  #Adds Feed Entries to DB, works with SimpleRSS feed. 
  def self.add_entries(entries, person)
    entries.each do |entry|
      unless exists? :guid => entry.guid
        create!(
          :text         => entry.title,
          :author       => person.name,
          :url          => entry.link,
          :published_at => entry.pubDate,
          :guid         => entry.guid,
          :person_id    => person.id
        )
      end
    end
  end
  
  #Adds Feed Entries to DB, works with FeedZirra feed. 
  #def self.add_entries(entries, person)
  #  entries.each do |entry|
  #    unless exists? :guid => entry.id
  #      create!(
  #        :text         => entry.title,
  #        :author       => person.name,
  #        :url          => entry.url,
  #        :published_at => entry.published,
  #        :guid         => entry.id,
  #        :person_id    => person.id
  #      )
  #    end
  #  end
  #end
  
end