class Person < ActiveRecord::Base
  
  require 'open-uri'  
  require 'json'
  #require 'typhoeus'
  require 'twitter'
  #require 'ar-extensions'  
  #require 'ar-extensions/adapters/mysql'
  #require 'ar-extensions/import/mysql' 
  #include Typhoeus
  require 'pstore'
  
  #associations
  has_and_belongs_to_many :project
  has_many :feed_entries, :dependent => :destroy
  after_destroy :destroy_relations
  
  #remote_defaults :on_success => lambda {|response| JSON.parse(response.body)},
  #                :on_failure => lambda {|response| puts "error code: #{response.code}"},
  #                :base_uri   => "http://twitter.com"
  #                  
  #
  #define_remote_method :twitter_user, :path => '/users/show.json',
  #                                    :headers => {"Authorization" => "Basic #{Base64.b64encode(TWITTER_USERNAME + ":" + TWITTER_PASSWORD)}"}
  #
  #define_remote_method :twitter_friends, :path => '/friends/ids.json'
  #define_remote_method :twitter_followers, :path => '/followers/ids.json'
  
  def destroy_relations
    File.delete FRIENDSHIP_IDS + self.twitter_id.to_s
    File.delete FOLLOWER_IDS + self.twitter_ids.to_s
  end
  
  def collect_friends twitter_id 
    twitter = Twitter::Client.from_config('config/twitter.yml', 'dev')
    begin
        friends_ids = twitter.graph(:friends, twitter_id)
    rescue
        friends_ids = []
        SystemMessage.add_message("error", "Collect Friends ", "Friends of Person with twitter id: " + twitter_id.to_s + " could not be found.")
        logger.error("ERROR: Collect Freinds of person with twitter id " + twitter_id.to_s + "was not possible.")
    end
    if friends_ids != [] 
      friends_ids_hash = Hash.new(0)
      store = PStore.new( FRIENDS_IDS_PATH + twitter_id.to_s)
      store.transaction{store[twitter_id] = friends_ids_hash} #empty store if updating      
      friends_ids.each do |friend_id|
        friends_ids_hash[friend_id] = 1
      end            
      store.transaction{store[twitter_id] = friends_ids_hash} #store entries
    end
  end
  
  def collect_followers twitter_id
    twitter = Twitter::Client.from_config('config/twitter.yml', 'dev')
    begin
      follower_ids = twitter.graph(:followers, twitter_id)
    rescue
      follower_ids = []
      SystemMessage.add_message("error", "Collect Followers", "Followers of Person with twitter id: " + twitter_id.to_s + " could be not found.")          
    end
    if follower_ids != []      
      follower_ids_hash = Hash.new(0)
      store = PStore.new(FOLLOWER_IDS_PATH + twitter_id.to_s)
      store.transaction{store[twitter_id] = follower_ids_hash} #empty store if updating
      follower_ids.each do |follower_id|
        follower_ids_hash[follower_id] = 1  
      end
      store.transaction{store[twitter_id] = follower_ids_hash} #store values
    end
  end
  
  
  def self.collect_person(twitter_id, project_id, max_collection, friends = true, followers = false)            
    
    if twitter_id.is_a?(Numeric)
      person = Person.find_by_twitter_id(twitter_id)        
    else
      person = Person.find_by_username(twitter_id)
    end    
    
    puts "COLLECTING PERSON " + twitter_id.to_s
    #Collect Person if not in DB
    if person == nil
      person = Person.twitter_user(:params => {:id => twitter_id})      
      if person == nil
        Delayed::Job.enqueue(CollectPersonJob.new(twitter_id,project_id,max_collection))         
        SystemMessage.add_message("error", "Collect Person ",  " Person with twitter id: " + twitter_id.to_s + " was not found.")
        logger.error "Person with twitter id: " + twitter_id.to_s + " was not found. Retrying."
      else          
        #Store Person
        person = Person.add_entry(person)      
        #Collect Friends      
        if friends
          if person.friends_count.to_i < max_collection.to_i
            person.collect_friends(person.twitter_id)
          end          
        end      
        #Collect Followers
        if followers
          if person.followers_count.to_i < max_collection.to_i
            person.collect_followers(person.twitter_id)
          end          
        end
        #Store Project
        if !Project.find(project_id).persons.include?(person)          
          Project.find(project_id).persons << person
        end              
      end
    end
    return person
  end
  
  def self.collect_person_and_friends(twitter_id, project_id,max)           
    person = Person.collect_person(twitter_id,project_id,max)
    person.friends_ids.each do |friend_id|
      Person.collect_person(friend_id,project_id,max)        
    end
    return person
  end
  
  def self.collect_person_and_followers(twitter_id,project_id,max)
    person = Person.collect_person(twitter_id, project_id, max, false, true)      
    person.follower_ids.each do |follower_id|
      Person.collect_person(follower_id, project_id, max, false, true)
    end
    return person
  end  
  
  
  def friends_ids_hash
    friends_ids_hash = Hash.new()
    store = PStore.new(FRIENDS_IDS_PATH + self.twitter_id.to_s)
    store.transaction{friends_ids_hash = store[self.twitter_id]}
    return friends_ids_hash    
  end
  
  def friends_ids
    self.friends_ids_hash.keys rescue []
  end
  
  def follower_ids_hash
    follower_ids_hash = Hash.new()
    store = PStore.new(FOLLOWER_IDS_PATH + self.twitter_id.to_s)
    store.transaction{follower_ids_hash = store[self.twitter_id]}
    return follower_ids_hash
  end
  
  def follower_ids
    self.follower_ids_hash.keys rescue []
  end
  
  def get_all_entries
    @feed_entries = FeedEntry.find(:all,  :conditions => { :person_id => self.id}, :order => 'published_at DESC')
  end
  
  def get_all_friends
    friends = []
    self.friends_ids.each do |id|
      unless Person.find_by_twitter_id(id).nil?
        friends  << Person.find_by_twitter_id(id)
      end      
    end
    return friends
  end

  def get_all_followers
    followers = []
    self.follower_ids.each do |id|
      unless Person.find_by_twitter_id(id).nil?
        followers << Person.find_by_twitter_id(id)  
      end      
    end
    return followers
  end
  
  def self.update_all_persons
    Project.all.each do |project|      
      if project.monitor_feeds == true        
        project.persons.each do |person|
          Delayed::Job.enqueue(UpdatePersonJob.new(person.twitter_id))  
        end
      SystemMessage.add_message("info", "Update all person stats",  "Project " + project.name + " persons (" + project.persons.count.to_s + ") have been scheduled for update.")
      end      
    end
  end
  
  def self.update_twitter_stats(twitter_id)
    tmp_person = Person.find_by_twitter_id(twitter_id)
    twitter_person = Person.twitter_user(:params => {:id => twitter_id})
    tmp_person.collect_friends(twitter_id) #update friends ids
    tmp_person.update_attributes(
          :name           => twitter_person['name'],
          :bio            => twitter_person['description'],
          :location       => twitter_person['location'],
          :picture        => twitter_person['profile_image_url'],          
          :time_offset    => twitter_person['time_zone'],
          :friends_count  => twitter_person['friends_count'],
          :followers_count => twitter_person['followers_count'],
          :statuses_count => twitter_person['statuses_count']
    )    
  end  
  
  #Adds one Person to to DB
  def self.add_entry(twitter_person)
    if Person.all(:conditions => ["twitter_id = ? ", twitter_person['id']]) == []
        create!(
          :name           => twitter_person['name'],
          :bio            => twitter_person['description'],
          :location       => twitter_person['location'],
          :picture        => twitter_person['profile_image_url'],
          :acc_created_at => twitter_person['created_at'],
          :time_offset    => twitter_person['time_zone'],
          :friends_count  => twitter_person['friends_count'],
          :followers_count => twitter_person['followers_count'],
          :statuses_count => twitter_person['statuses_count'],
          :username       => twitter_person['screen_name'],
          :twitter_id     => twitter_person['id']
        )
    end
    return Person.find_by_twitter_id(twitter_person['id'])
  end
  
end
