class ProjectsController < ApplicationController
  # GET /projects
  # GET /projects.xml
  require 'csv'
  layout 'default'
  
  def index
    @projects = Project.all
    @delayed_jobs = Delayed::Job.all
    
    respond_to do |format|
      format.html # index.html.erb
      format.xml  { render :xml => @projects }
    end
  end

  # GET /projects/1
  # GET /projects/1.xml
  def show
    @project = Project.find(params[:id])

    respond_to do |format|
      format.html # show.html.erb
      format.xml  { render :xml => @project }
    end
  end

  # GET /projects/new
  # GET /projects/new.xml
  def new
    @project = Project.new

    respond_to do |format|
      format.html # new.html.erb
      format.xml  { render :xml => @project }
    end
  end

  # GET /projects/1/edit
  def edit
    @project = Project.find(params[:id])
  end

  # POST /projects
  # POST /projects.xml
  def create
    @project = Project.new(params[:project])

    respond_to do |format|
      if @project.save
        flash[:notice] = 'Project was successfully created.'
        format.html { redirect_to(@project) }
        format.xml  { render :xml => @project, :status => :created, :location => @project }
      else
        format.html { render :action => "new" }
        format.xml  { render :xml => @project.errors, :status => :unprocessable_entity }
      end
    end
  end

  # PUT /projects/1
  # PUT /projects/1.xml
  def update
    @project = Project.find(params[:id])

    respond_to do |format|
      if @project.update_attributes(params[:project])
        flash[:notice] = 'Project was successfully updated.'
        format.html { redirect_to(@project) }
        format.xml  { head :ok }
      else
        format.html { render :action => "edit" }
        format.xml  { render :xml => @project.errors, :status => :unprocessable_entity }
      end
    end
  end
  
  def collect_all_project_entries
    @project = Project.find(params[:id])
    total_entries = 0
    
    puts "Analyzing " + @project.name.to_s  + " with " + @project.persons.count.to_s + " persons."
    
    @project.persons.each do |person|
      total_entries = total_entries + person.statuses_count
      Delayed::Job.enqueue(CollectAllFeedEntriesJob.new(person.id))  
    end    
    
    respond_to do |format|
      flash[:notice] = total_entries.to_s + ' feed entries of the ' + @project.persons.count.to_s + ' people on this project will be collected. Please give it some time to finish.'
      format.js do
        render :update do |page|          
          page.reload
        end
      end
    end    
  end
  
  def update_all_project_entries
    @project = Project.find(params[:id])
    total_entries = 0
            
    @project.persons.each do |person|
      total_entries = total_entries + person.statuses_count
      Delayed::Job.enqueue(UpdateAllFeedEntriesJob.new(person.id))  
    end    
    
    respond_to do |format|
      flash[:notice] = total_entries.to_s + ' feed entries of the ' + @project.persons.count.to_s + ' people on this project will be updated. Please give it some time to finish.'
      format.js do
        render :update do |page|          
          page.reload
        end
      end
    end
    
  end
  
  def update_all_project_people
    @project = Project.find(params[:id])    
        
    @project.persons.each do |person|
      Delayed::Job.enqueue(UpdatePersonJob.new(person.twitter_id))  
    end        
    
    respond_to do |format|
      flash[:notice] = @project.persons.count.to_s + ' people on this project will be updated. Please give it some time to finish.'
      format.js do
        render :update do |page|          
          page.reload
        end
      end
    end
  end

  
  def csv_import
     @project = Project.find(params[:id])
     @parsed_file=CSV::Reader.parse(params[:dump][:file])
     maxfriends = params[:maxfriends]
     
     n=0
     @parsed_file.each  do |row|
        username = URI.parse(row.to_s).path.reverse.chop.reverse
        logger.info "CSV Import: Importing person " + username
        Delayed::Job.enqueue(CollectPersonJob.new(username,@project.id,maxfriends))  
        n=n+1          
     end
     respond_to do |format|
      flash[:notice]="CSV Import Successful,  #{n} new Persons will be added to data base"
      format.html { redirect_to projects_path }
     end           
   end
  
  #exports Relationships between people to UCI_NET
  def generate_csv
    @project = Project.find(params[:id])
    
    content_type = if request.user_agent =~ /windows/i
                 ' application/vnd.ms-excel '
               else
                 ' text/csv '
               end
    
    project_net = @project.find_all_friend_connections
    
    CSV::Writer.generate(output = "") do |csv|
      csv << ["DL n=" + @project.persons.count.to_s ]
      csv << ["format = edgelist1"]
      csv << ["labels embedded:"]
      csv << ["data:"]
      project_net.each do |entry|
        csv << [entry[0], entry[1], "1"]
      end
    end
    send_data(output,
            :type => content_type,
            :filename => @project.name.to_s + ".csv")
  end
  
  def generate_stats
    @project = Project.find(params[:id])
    
    content_type = if request.user_agent =~ /windows/i
             ' application/vnd.ms-excel '
           else
             ' text/csv '
           end
    
    CSV::Writer.generate(output = "") do |csv|
      csv << ["Person", "Twitter_Username", "Friends", "Followers", "Messages", "Acc Created"]
      @project.persons.each do |person|
        csv << [person.name, person.username, person.friends_count, person.followers_count, person.statuses_count, person.acc_created_at ]
      end
    end
    send_data(output,
            :type => content_type,
            :filename => @project.name.to_s + "_stats" + ".csv")
    
  end
  
    #exports Relationships between people to UCI_NET
  def generate_igraph
    @project = Project.find(params[:id])
    
    content_type = if request.user_agent =~ /windows/i
                 ' application/vnd.ms-excel '
               else
                 ' text/csv '
               end
    
    project_net = Follower.all(:conditions => ["project_id = ?", @project.id])    
    
    CSV::Writer.generate(output = "") do |csv|
      project_net.each do |entry|
        follower_id = Person.find_by_username(entry.person).id
        followed_by_id = Person.find_by_username(entry.followed_by_person).id
        csv << [follower_id, followed_by_id]
      end
    end
    send_data(output,
            :type => content_type,
            :filename => @project.name.to_s  + ".txt")
  end
  
  def generate_twitter_links
        @project = Project.find(params[:id])
    content_type = if request.user_agent =~ /windows/i
             ' application/vnd.ms-excel '
           else
             ' text/csv '
           end
    
    CSV::Writer.generate(output = "") do |csv|      
      @project.persons.each do |person|
        csv << ["http://twitter.com/" + person.username]
      end
    end
    send_data(output,
            :type => content_type,
            :filename => @project.name.to_s + "_twitter_links" + ".csv")
  end
  
  def export_to_uci_net
    render :update do |page|
      page.redirect_to :action => "generate_csv", :id => params[:id]
    end
  end
  
  def export_person_stats
    render :update do |page|
      page.redirect_to :action => "generate_stats", :id => params[:id]
    end
  end
  
    
  def export_twitter_links
    render :update do |page|
      page.redirect_to :action => "generate_twitter_links", :id => params[:id]
    end
  end
  
  # DELETE /projects/1
  # DELETE /projects/1.xml
  def destroy
    @project = Project.find(params[:id])
    @project.destroy

    respond_to do |format|
      format.html { redirect_to(projects_url) }
      format.xml  { head :ok }
    end
  end
end
